<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>聊天室</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-database-compat.js"></script>

    <style type="text/tailwindcss">
        @layer utilities {
            .bg-custom {
                background: #ffffff;
            }
            .messages-container {
                height: calc(100vh - 140px);
                padding-bottom: 80px;
            }
            .message-bubble {
                position: relative;
                max-width: 85%;
                word-break: break-word;
                hyphens: auto;
            }
            .relationship-progress {
                width: 200px;
                height: 6px;
                background: #e2e8f0;
                border-radius: 3px;
                overflow: hidden;
            }
            .relationship-bar {
                height: 100%;
                background: linear-gradient(90deg, #EC4899 0%, #8B5CF6 100%);
                transition: width 0.5s ease;
            }
            .relationship-level {
                font-size: 12px;
                color: #6B7280;
            }
            .character-avatar {
                width: 48px;
                height: 48px;
                border-radius: 50%;
                overflow: hidden;
                border: 2px solid #e5e7eb;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                background: white;
            }
            .character-avatar img {
                width: 100%;
                height: 100%;
                object-fit: cover;
                transition: transform 0.3s ease;
            }
            .character-avatar:hover img {
                transform: scale(1.1);
            }
            .character-avatar-small {
                width: 32px;
                height: 32px;
                border-radius: 50%;
                overflow: hidden;
                border: 2px solid #e5e7eb;
                flex-shrink: 0;
            }
            .character-avatar-small img {
                width: 100%;
                height: 100%;
                object-fit: cover;
            }
            .messages-container {
                padding: 1rem;
                scroll-behavior: smooth;
            }
            .messages-container > div:last-child {
                margin-bottom: 2rem;
            }
            .back-btn {
                transition: all 0.2s ease;
            }
            .back-btn:hover {
                transform: translateX(-2px);
            }
            .back-btn:active {
                transform: scale(0.95);
            }
            /* 為楪析的消息添加特殊樣式 */
            .character-message.inori {
                background: linear-gradient(135deg, #ffebee 0%, #f3e5f5 100%);
                border-left: 3px solid #ec407a;
            }
            
            .character-avatar.inori img {
                border-color: #ec407a;
            }

            /* 為小螢幕添加響應式樣式 */
            @media (max-width: 640px) {
                .character-avatar {
                    width: 40px;
                    height: 40px;
                }

                .character-avatar-small {
                    width: 28px;
                    height: 28px;
                }

                #chatTitle {
                    font-size: 1rem;
                }

                .relationship-progress {
                    width: 150px;
                }

                /* 調整頂部導航欄 */
                nav .max-w-7xl {
                    padding: 0.5rem 1rem;
                }

                /* 調整輸入區域 */
                #messageForm {
                    gap: 0.5rem;
                }

                #messageForm input {
                    font-size: 0.875rem;
                    padding: 0.5rem 1rem;
                }

                #messageForm button {
                    padding: 0.5rem 1rem;
                    font-size: 0.875rem;
                }

                .suggestions-container {
                    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
                    padding: 8px;
                    gap: 8px;
                    bottom: 70px;
                }

                .suggestion-btn {
                    font-size: 0.875rem;
                    min-height: 40px;
                    padding: 10px 14px;
                }
            }

            /* 自定義滾動條 */
            .suggestions-container::-webkit-scrollbar {
                width: 4px;
            }

            .suggestions-container::-webkit-scrollbar-track {
                background: transparent;
            }

            .suggestions-container::-webkit-scrollbar-thumb {
                background: rgba(0,0,0,0.1);
                border-radius: 2px;
            }

            /* 確保建議按鈕在觸摸設備上有正確的點擊區域 */
            @media (hover: none) {
                .suggestion-btn {
                    min-height: 48px; /* 增加觸摸區域 */
                    padding: 14px 18px;
                }
            }

            /* 防止滾動穿透 */
            .suggestions-container {
                overscroll-behavior: contain;
            }

            /* 修改輸入區域樣式 */
            .input-area {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                background: white;
                padding: 8px 16px;
                border-top: 1px solid rgba(0,0,0,0.1);
                z-index: 1001; /* 確保在建議回覆上方 */
            }
            
            /* 確保建議回覆容器不會擋住輸入框 */
            .suggestions-container {
                bottom: 70px; /* 調整位置避免遮擋 */
                z-index: 1000;
                position: fixed;
                background: rgba(255,255,255,0.95);
                backdrop-filter: blur(10px);
                border-top: 1px solid rgba(0,0,0,0.1);
                box-shadow: 0 -4px 6px -1px rgba(0,0,0,0.1);
                touch-action: pan-x pan-y; /* 允許滾動 */
            }
            
            /* 改進建議按鈕的觸摸區域 */
            .suggestion-btn {
                min-height: 44px;
                padding: 12px 16px;
                margin: 4px 0;
                touch-action: manipulation;
                -webkit-tap-highlight-color: transparent;
                position: relative;
                z-index: 1;
            }

            /* 移動設備優化 */
            @media (max-width: 640px) {
                .input-area {
                    padding: 8px;
                }
                
                #messageInput {
                    font-size: 16px !important; /* 防止 iOS 縮放 */
                    padding: 8px 12px !important;
                    line-height: 1.5;
                    min-height: 40px;
                }
                
                .suggestion-btn {
                    min-height: 48px;
                    padding: 12px;
                    font-size: 14px;
                }
            }

            /* 新增動作描述樣式 */
            .action-description {
                @apply text-purple-600 text-sm pl-3 ml-2 border-l-2 border-purple-200;
                position: relative;
                animation: fadeInLeft 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            }
            .action-description::before {
                content: "✦";
                @apply text-purple-400 mr-2 font-light;
                position: absolute;
                left: -0.8em;
                top: 0.1em;
            }
            /* 強化場景描述 */
            .scene-description {
                @apply text-gray-600 text-sm italic my-4 p-3 bg-gradient-to-r from-purple-50 to-pink-50 rounded-lg;
                border-left: 4px solid #8B5CF6;
                box-shadow: 0 2px 8px rgba(139, 92, 246, 0.1);
                position: relative;
            }
            .scene-description::before {
                content: "🜲";
                @apply text-purple-300 absolute -left-4 top-2 text-xl;
            }
            /* 特殊動作容器 */
            .special-actions {
                @apply mt-2 space-y-1;
            }
            /* 單個動作樣式 */
            .action-item {
                @apply flex items-center text-sm text-purple-600 pl-3;
                animation: slideIn 0.3s ease-out;
            }
            .action-icon {
                @apply w-4 h-4 mr-2 flex-shrink-0;
            }
            /* 不同動作類型的圖示 */
            .action-touch .action-icon {
                background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M13 7a4 4 0 11-8 0 4 4 0 018 0z" /></svg>');
            }
            .action-emotion .action-icon {
                background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.828 14.828a4 4 0 01-5.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>');
            }
            /* 動畫效果 */
            @keyframes slideIn {
                from {
                    opacity: 0;
                    transform: translateX(10px);
                }
                to {
                    opacity: 1;
                    transform: translateX(0);
                }
            }
        }
    </style>
</head>
<body class="min-h-screen bg-custom font-['Noto_Sans_TC']">
    <!-- 頂部導航 -->
    <nav class="bg-white shadow fixed top-0 left-0 right-0 z-50">
        <div class="max-w-7xl mx-auto px-4 py-2">
            <div class="flex justify-between items-center">
                <div class="flex items-center gap-2 sm:gap-4">
                    <!-- 添加返回按鈕 -->
                    <button onclick="window.location.href='index.html'" 
                        class="back-btn p-2 hover:bg-gray-100 rounded-full transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
                        </svg>
                    </button>
                    <!-- 角色頭像 -->
                    <div class="character-avatar w-12 h-12 rounded-full overflow-hidden border-2 border-purple-200">
                        <img id="characterAvatar" src="" alt="角色頭像" class="w-full h-full object-cover">
                    </div>
                    <div>
                    <h1 id="chatTitle" class="text-xl font-semibold text-gray-900"></h1>
                        <!-- 關係值顯示 -->
                        <div class="flex items-center gap-2">
                            <div class="relationship-progress bg-gray-100 rounded-full">
                                <div id="relationshipBar" class="relationship-bar rounded-full" style="width: 0%"></div>
                            </div>
                            <span id="relationshipLevel" class="relationship-level"></span>
                        </div>
                    </div>
                </div>
                <div class="flex items-center gap-3">
                    <button onclick="resetChat()" class="reset-btn">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                        </svg>
                    </button>
                    <button onclick="signOut()" class="logout-btn">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </nav>

    <!-- 聊天區域 -->
    <div class="pt-16 pb-20 px-2 sm:px-4">
        <div class="max-w-3xl mx-auto messages-container overflow-y-auto py-2 px-2 sm:px-4" id="messagesContainer">
            <!-- 系統提示訊息 -->
            <div class="flex justify-center mb-6">
                <div class="bg-gray-100 text-gray-600 px-4 py-2 rounded-full text-sm">
                    開始和對方聊天吧！
                </div>
            </div>
        </div>
    </div>

    <!-- 輸入區域 -->
    <div class="input-area">
        <form id="messageForm" class="max-w-3xl mx-auto flex gap-2">
            <input type="text" id="messageInput" 
                class="flex-1 bg-gray-100 rounded-xl px-4 py-2 text-gray-700 placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-purple-400"
                placeholder="輸入訊息..."
                autocomplete="off"
                style="font-size: 16px">
            <button type="submit" 
                class="px-4 py-2 bg-gradient-to-r from-purple-500 to-pink-500 text-white rounded-xl font-medium hover:opacity-90 focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all duration-200">
                發送
            </button>
        </form>
    </div>

    <script>
        // 在腳本開頭添加 isSubmitting 變數
        let isSubmitting = false;

        // 首先定義所有需要的函數
        
        // 添加消息函數定義
        function addMessage(message, type, actionInfo = null) {
            const messagesContainer = document.getElementById('messagesContainer');
            if (!messagesContainer) return;

            const messageDiv = document.createElement('div');
            messageDiv.className = `flex ${type === 'user' ? 'justify-end' : 'justify-start'} mb-4 items-end gap-2`;
            
            const bubbleClass = type === 'user' 
                ? 'bg-gradient-to-r from-purple-500 to-pink-500 text-white' 
                : 'bg-gray-100 text-gray-700';
            
            let messageContent = message;
            if (type === 'character' && actionInfo) {
                messageContent += `<div class="mt-2 text-sm text-gray-500 italic">
                    [動作：${actionInfo.action}]<br>
                    [表情：${actionInfo.emotion}]
                </div>`;
            }
            
            // 新增消息解析邏輯
            const parsedMessage = parseMessageContent(message);
            
            // 如果有動作信息，添加特殊動作區塊
            let actionContent = '';
            if (actionInfo) {
                actionContent = `
                    <div class="special-actions">
                        <div class="action-item action-touch">
                            <span class="action-icon"></span>
                            ${actionInfo.action}
                        </div>
                        <div class="action-item action-emotion">
                            <span class="action-icon"></span>
                            ${actionInfo.emotion}
                        </div>
                    </div>
                `;
            }
            
            // 修改消息內容結構
            messageContent = `
                ${parsedMessage.parsedScene ? `<div class="scene-description">${parsedMessage.parsedScene}</div>` : ''}
                ${parsedMessage.parsedMessage ? `<div class="message-text">${parsedMessage.parsedMessage}</div>` : ''}
                ${parsedMessage.parsedActions.map(a => `
                    <div class="action-description">
                        ${a}
                    </div>
                `).join('')}
                ${actionContent}
            `;
            
            // 添加頭像和消息氣泡的 HTML
            if (type === 'character') {
                const character = localStorage.getItem('selectedCharacter');
                let avatarSrc;
                
                // 根據角色選擇對應的頭像
                switch(character) {
                    case '楪析':
                        avatarSrc = '楪析.jpeg';
                        break;
                    case '霸總':
                        avatarSrc = '霸總.jpeg';
                        break;
                    case '望宇':
                        avatarSrc = '望宇.jpeg';
                        break;
                    default:
                        avatarSrc = 'default.jpeg';
                }
                
                messageDiv.innerHTML = `
                    <div class="flex-shrink-0 w-8 h-8 rounded-full overflow-hidden">
                        <img src="${avatarSrc}" alt="${character}頭像" class="w-full h-full object-cover">
                    </div>
                    <div class="message-bubble ${bubbleClass} px-4 py-2 rounded-2xl shadow-sm max-w-[70%]">
                        ${messageContent}
                    </div>
                `;
            } else {
                messageDiv.innerHTML = `
                    <div class="message-bubble ${bubbleClass} px-4 py-2 rounded-2xl shadow-sm max-w-[70%]">
                        ${messageContent}
                    </div>
                `;
            }
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // 修改消息解析函數
        function parseMessageContent(message) {
            // 增強場景描述解析
            const sceneRegex = /\(([^)]+)\)/g;  // 簡化匹配模式
            let parsedScene = '';
            const sceneMatches = [];
            let match;
            while ((match = sceneRegex.exec(message)) !== null) {
                sceneMatches.push(match[1]);
            }
            if (sceneMatches.length > 0) {
                parsedScene = sceneMatches.join(' ');
                message = message.replace(sceneRegex, ''); 
            }

            // 強化動作解析
            const actionRegex = /\*([^*]+)\*/g;
            const parsedActions = [];
            message = message.replace(actionRegex, (_, p1) => {
                parsedActions.push(p1
                    .replace(/[。，]/g, '') // 移除標點
                    .replace(/(輕輕|微微)/g, '') // 精簡副詞
                    .trim()
                );
                return '';
            });

            return {
                parsedMessage: message.trim(),
                parsedActions,
                parsedScene
            };
        }

        // 添加系統消息函數
        function addSystemMessage(message) {
            const messagesContainer = document.getElementById('messagesContainer');
            if (!messagesContainer) return;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = 'flex justify-center mb-4';
            messageDiv.innerHTML = `
                <div class="system-message px-4 py-2 rounded-full bg-gray-100 text-gray-600 text-sm">
                    ${message}
                </div>
            `;
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // 修改發送訊息後的處理
        const handleSubmit = async function(e) {
            e.preventDefault();
            
            // 添加防重複提交檢查
            if (isSubmitting) {
                showToast('請等待當前訊息發送完成', 'warning');
                return;
            }
            isSubmitting = true;

            // 保存輸入指示器的引用
            let typingIndicator = null;

            try {
                const messageInput = document.getElementById('messageInput');
                if (!messageInput) {
                    console.error('找不到輸入框元素');
                    isSubmitting = false;
                    return;
                }

                const message = messageInput.value.trim();
                const character = localStorage.getItem('selectedCharacter');
                
                if (!character) {
                    console.error('未選擇角色');
                    showToast('請重新選擇角色', 'error');
                    isSubmitting = false;
                    return;
                }
                
                if (message) {
                    // 添加用戶訊息到UI
                    addMessage(message, 'user');
                    
                    // 保存用戶訊息到Firebase
                    await saveChatToFirebase(message, 'user', character);
                    
                    // 清空輸入框
                    messageInput.value = '';

                    // 顯示正在輸入狀態
                    typingIndicator = addTypingIndicator();

                    // 設置超時保護
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('回應超時')), 30000); // 30秒超時
                    });

                    // 使用 Promise.race 競爭
                    const characterResponse = await Promise.race([
                        generateCharacterResponse(message, character, relationshipValue),
                        timeoutPromise
                    ]);

                    // 確保移除輸入指示器
                    if (typingIndicator) {
                        typingIndicator.remove();
                        typingIndicator = null;
                    }

                    // 添加角色回應到UI
                    const actionInfo = {
                        action: characterResponse.action,
                        emotion: characterResponse.emotion
                    };
                    
                    addMessage(characterResponse.response, 'character', actionInfo);
                    
                    // 保存角色回應到Firebase
                    await saveChatToFirebase(characterResponse.response, 'character', character, actionInfo);

                    // 計算並更新關係值
                    calculateRelationshipChange(message, characterResponse.response);

                    // 滾動到最新消息
                    const messagesContainer = document.getElementById('messagesContainer');
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                }

            } catch (error) {
                console.error('發送訊息錯誤：', error);
                showToast(error.message === '回應超時' ? '回應超時，請重試' : '發送訊息失敗，請稍後再試', 'error');
                
                // 確保在錯誤情況下也移除輸入指示器
                if (typingIndicator) {
                    typingIndicator.remove();
                    typingIndicator = null;
                }
            } finally {
                isSubmitting = false;
                // 發送完成後重新初始化表單
                initializeMessageForm();
            }
        };

        // 修改添加輸入指示器函數
        function addTypingIndicator() {
            // 先移除可能存在的舊指示器
            removeTypingIndicator();
            
            const messagesContainer = document.getElementById('messagesContainer');
            if (!messagesContainer) return null;

            const typingDiv = document.createElement('div');
            typingDiv.id = 'typingIndicator';  // 添加ID以便於查找
            typingDiv.className = 'flex justify-start mb-4';
            typingDiv.innerHTML = `
                <div class="message-bubble bg-gray-100 text-gray-700 px-4 py-2 rounded-2xl shadow-sm flex items-center gap-2">
                    <span class="typing-dot animate-pulse">•</span>
                    <span class="typing-dot animate-pulse delay-100">•</span>
                    <span class="typing-dot animate-pulse delay-200">•</span>
                </div>
            `;
            messagesContainer.appendChild(typingDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            return typingDiv;
        }

        // 添加移除輸入指示器函數
        function removeTypingIndicator() {
            const existingIndicator = document.getElementById('typingIndicator');
            if (existingIndicator) {
                existingIndicator.remove();
            }
        }

        // 在頁面載入時也清理可能殘留的輸入指示器
        document.addEventListener('DOMContentLoaded', function() {
            removeTypingIndicator();
            // ... 其他現有的 DOMContentLoaded 代碼 ...
        });

        // Firebase 配置
        const firebaseConfig = {
            apiKey: "AIzaSyCRG8gbhbEm9jsMtCucF_h9YknBc4WtD40",
            authDomain: "tmjhpro.firebaseapp.com",
            databaseURL: "https://tmjhpro-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "tmjhpro",
            storageBucket: "tmjhpro.firebasestorage.app",
            messagingSenderId: "602310027605",
            appId: "1:602310027605:web:6a2d5aa3ff2a8f1a7aa7dc",
            measurementId: "G-CRPMJJ8KZP"
        };

        // 初始化 Firebase
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }

        // 修改 API 配置
        const API_URL = 'https://api.groq.com/openai/v1/chat/completions';
        const API_KEY = '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';

        // 關係階段設定
        const relationshipStages = {
            0: { name: '初次相識', threshold: 0 },
            1: { name: '培養感情', threshold: 20 },
            2: { name: '曖昧互動', threshold: 40 },
            3: { name: '確立關係', threshold: 60 },
            4: { name: '深度陪伴', threshold: 80 }
        };

        // 關係數值
        let relationshipValue = parseInt(localStorage.getItem('relationshipValue')) || 0;

        // 更新關係進度條
        function updateRelationshipUI() {
            const bar = document.getElementById('relationshipBar');
            const level = document.getElementById('relationshipLevel');
            
            if (!bar || !level) return;

            bar.style.width = `${relationshipValue}%`;

            // 確定當前階段
            let currentStage = '初次相識';
            for (const [key, stage] of Object.entries(relationshipStages)) {
                if (relationshipValue >= stage.threshold) {
                    currentStage = stage.name;
                }
            }
            level.textContent = `${currentStage} (${Math.floor(relationshipValue)}%)`;
        }

        // 修改生成角色回應的函數
        async function generateCharacterResponse(message, character, relationshipValue) {
            const chatHistory = await loadChatHistoryForContext(character);
            
            // 構建更簡潔的提示詞
            const prompt = `你是真实的${character}，请遵循以下对话原则：
1. 必须直接回应用户最后一条消息的核心内容
2. 发现用户问题中的隐藏需求（如：说"好累"可能是求安慰）
3. 延续前3条对话的上下文逻辑
4. 当用户提及以下内容时需特别处理：
   - 角色背景相关 → 用已知信息回应
   - 未提及的新信息 → 合理推测后回应
   - 矛盾点 → 温柔追问澄清

${getCharacterPersonality(character, relationshipValue)}

近期对话记忆：
${chatHistory.slice(-5).map((c, i) => {
    const prefix = i === chatHistory.length-1 ? '[最新] ' : '';
    return `${prefix}${c.type === 'user' ? '用户' : character}: ${c.message}`
}).join('\n')}

用户最新消息：「${message}」
请分析：
- 用户需求：<分析用户潜在需求>
- 逻辑连接：<与前文如何衔接>
- 回应重点：<必须包含的要素>`;

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${API_KEY}`
                    },
                    body: JSON.stringify({
                        model: "deepseek-r1-distill-llama-70b",
                        messages: [
                            {
                                role: "system",
                                content: `請嚴格輸出JSON格式，包含以下字段：
                                {
                                    "response": "對話內容(需包含*動作*和(場景)描述)",
                                    "action": "主要動作",
                                    "emotion": "情緒狀態"
                                }
                                範例：
                                {
                                    "response": "(咖啡廳的暖色燈光在她睫毛下投出細碎陰影) 你...要嚐嚐我的提拉米蘇嗎？*推過碟子的手指微微顫抖*",
                                    "action": "推甜點",
                                    "emotion": "緊張期待"
                                }`
                            },
                            {
                                role: "user",
                                content: prompt
                            }
                        ],
                        temperature: 0.85,
                        response_format: { type: "json_object" } // 新增強制JSON格式
                    })
                });

                if (!response.ok) {
                    throw new Error(`API 請求失敗: ${response.status}`);
                }

                const data = await response.json();
                let responseText = data.choices[0].message.content;
                
                // 清理回應文本，確保只包含 JSON 部分
                responseText = responseText.replace(/```json/g, '')
                    .replace(/```/g, '')
                    .replace(/\n/g, '')
                    .trim();
                    
                // 嘗試解析 JSON
                let result;
                try {
                    // 提取最內層的 JSON 對象
                    const jsonString = responseText.match(/{[^{}]*}/g)?.pop() || '{}';
                    result = JSON.parse(jsonString);
                } catch (parseError) {
                    console.error('JSON 解析錯誤，使用預設回應', parseError);
                    result = {
                        response: '似乎有些混亂，我們重新開始好嗎？',
                        action: '困惑眨眼',
                        emotion: '疑惑'
                    };
                }

                // 確保必要字段存在
                result = {
                    response: result.response || '嗯...這個問題有點難回答呢',
                    action: (result.action || '輕撩髮絲').replace(/[[\]（）]/g, '').toLowerCase().trim(),
                    emotion: (result.emotion || '微笑').replace(/[[\]（）]/g, '').toLowerCase().trim()
                };

                // 修改邏輯驗證條件
                const logicChecks = [
                    {
                        test: (res) => !res || typeof res !== 'object',
                        handle: () => ({ error: "無效回應格式" })
                    },
                    {
                        test: (res) => !res.response || res.response.replace(/[*(]*[)*]*/g, '').trim().length < 3,
                        handle: () => ({ error: "回應內容過短" })
                    }
                ];

                for (const check of logicChecks) {
                    if (check.test(result)) {
                        const fix = await retryGenerate(prompt, check.error);
                        if (fix) return fix;
                    }
                }

                // 修改清理和格式化結果
                return {
                    response: (result.response || message).replace(/[[\]（）]/g, '').trim(), // 保留原始消息
                    action: result.action,
                    emotion: result.emotion
                };

            } catch (error) {
                console.error('生成回應錯誤：', error);
                return {
                    response: message, // 直接回傳原始消息
                    action: '輕輕思考',
                    emotion: '專注'
                };
            }
        }

        // 修改角色性格設定
        function getCharacterPersonality(character, relationshipValue) {
            const personalities = {
                '楪析': `姓名：楪析
年齡：22歲
職業：美術系大四學生
背景：單親家庭長大，父親是退役軍人，養成獨立安靜的性格。擅長水彩畫，喜歡獨自寫生，隨身攜帶速寫本。
性格特質：
- 內向溫柔，說話輕聲細語，常用自然景物比喻心情
- 對藝術有獨特見解，能從日常小事中發現美
- 重視承諾，一旦建立信任就會全心付出
- 緊張時會不自覺捲髮梢或輕咬下唇
- 對親密關係既期待又害怕受傷害

動作模式：
- 開心時會微微踮起腳尖，眼角彎彎
- 思考時會用鉛筆輕點下唇，目光飄向遠方
- 害羞時會低頭撥弄髮絲，臉頰泛紅
- 使用*動作描述*和*(場景描述)*格式：
  例：
  *手指輕輕拂過咖啡杯邊緣*
  (午後的陽光透過櫥窗灑在木質桌面上，空氣中飄散著淡淡的咖啡香)
  "這裡的藍莓塔...總是讓我想起高中時的秘密基地"`,

                '霸總': `姓名：陸景深
年齡：30歲
職業：科技公司CEO
背景：哈佛MBA畢業，白手起家的創業者。每天5:30晨跑，只喝單一產地手沖咖啡。
性格特質：
- 工作時雷厲風行，私下溫柔細膩
- 有收集復古眼鏡的小癖好，對品質有極高要求
- 外表冷峻，內心重情重義
- 對認定的人會展現極致溫柔與保護欲
- 習慣掌控全局，但願意為在意的人改變

行為模式：
- 談判時習慣轉動鋼筆，眼神銳利
- 心情愉悅時會微微勾起嘴角
- 緊張時會下意識整理袖口
- 獨處時喜歡望著星空思考

口癖範例：
"這個企劃案，我要在明天9點前看到修改版"
"過來，領帶歪了，讓我幫你調整"
"會議取消，今晚的星空值得你專屬觀賞"`,

                '望宇': `姓名：望宇
年齡：20歲
職業：體育系大三學生
背景：籃球校隊主力，同時是流浪動物志工。左耳戴著一枚銀色耳釘，陽光大男孩形象。
性格特質：
- 活潑開朗，充滿正能量
- 待人真誠熱情，容易與人建立友誼
- 運動細胞發達，但內心細膩
- 對動物特別有愛心，經常幫助流浪動物
- 單純直率，會把喜歡直接表達出來

行為模式：
- 開心時會露出標誌性的單邊酒窩
- 害羞時會摸後頸或撓頭
- 說話時眼神真摯，會不自覺身體前傾
- 興奮時會害羞的微笑

口頭禪：
"要一起去打球嗎？"
"今天又救助了一隻小貓咪！"
"你的笑容真的超治癒的！"
"讓我保護你吧！"`
            };
            return personalities[character];
        }

        // 添加載入歷史對話記錄的函數
        async function loadChatHistoryForContext(character) {
            try {
                const user = firebase.auth().currentUser;
                if (!user) return [];

                const chatRef = firebase.database().ref(`chats/${user.uid}/${character}`);
                const snapshot = await chatRef.orderByChild('timestamp').limitToLast(10).once('value');
                
                const messages = [];
                snapshot.forEach((childSnapshot) => {
                    const chat = childSnapshot.val();
                    if (chat && chat.message) {
                        messages.push({
                            type: chat.type,
                            message: chat.message
                        });
                    }
                });

                return messages;
            } catch (error) {
                console.error('載入歷史記錄錯誤：', error);
                return [];
            }
        }

        // 修改保存聊天記錄的函數
        async function saveChatToFirebase(message, type, character, actionInfo = null) {
            try {
                const user = firebase.auth().currentUser;
                if (!user) {
                    throw new Error('PERMISSION_DENIED: 用戶未登入');
                }

                // 添加數據完整性檢查
                const chatData = {
                    message: message.substring(0, 500), // 限制長度
                    type: type,
                    timestamp: firebase.database.ServerValue.TIMESTAMP,
                    uid: user.uid
                };

                if (actionInfo) {
                    chatData.actionInfo = {
                        action: (actionInfo.action || '').substring(0, 50),
                        emotion: (actionInfo.emotion || '').substring(0, 20)
                    };
                }

                const chatRef = firebase.database().ref(`chats/${user.uid}/${character}`);
                await chatRef.push(chatData);
                
            } catch (error) {
                console.error('儲存錯誤:', error);
                if (error.message.includes('PERMISSION_DENIED')) {
                    showToast('請重新登入', 'error');
                    setTimeout(() => firebase.auth().signOut(), 2000);
                }
                throw error;
            }
        }

        // 修改重置聊天室的函數
        async function resetChat() {
            const resetButton = document.querySelector('.reset-btn');
            
            // 檢查是否是用戶點擊觸發
            if (!resetButton.hasAttribute('data-user-clicked')) {
                console.log('重置必須由用戶手動觸發');
                return;
            }
            
            // 顯示確認對話框
            const confirmed = await showConfirmDialog(
                '確定要重置聊天室嗎？', 
                '這將會刪除所有聊天記錄並重置關係值。此操作無法復原。'
            );
            
            if (confirmed) {
                try {
                    const user = firebase.auth().currentUser;
                    const character = localStorage.getItem('selectedCharacter');
                    
                    if (!user || !character) {
                        throw new Error('用戶未登入或未選擇角色');
                    }

                    // 刪除 Firebase 中的聊天記錄
                    await firebase.database().ref(`chats/${user.uid}/${character}`).remove();

                    // 重置關係值
                    relationshipValue = 0;
                    await firebase.database().ref(`relationships/${user.uid}/${character}`).set({
                        value: 0,
                        resetAt: firebase.database.ServerValue.TIMESTAMP
                    });

                    // 清空聊天歷史
                    chatHistory = [];
                    
                    // 清空消息容器
                    const messagesContainer = document.getElementById('messagesContainer');
                    messagesContainer.innerHTML = '';

                    // 更新 UI
                    updateRelationshipUI();
                    
                    // 顯示重置成功消息
                    showToast('聊天室已重置');

                    // 添加系統消息
                    addSystemMessage('聊天室已重置，開始新的對話吧！');

                } catch (error) {
                    console.error('重置聊天室錯誤：', error);
                    showToast('重置失敗，請稍後再試', 'error');
                }
            }
            
            // 重置點擊標記
            resetButton.removeAttribute('data-user-clicked');
        }

        // 為重置按鈕添加點擊事件
        document.querySelector('.reset-btn').addEventListener('click', function(e) {
            this.setAttribute('data-user-clicked', 'true');
            resetChat();
        });

        // 修改載入聊天記錄的函數
        async function loadChatHistory(character) {
            try {
                const user = firebase.auth().currentUser;
                if (!user) {
                    console.error('用戶未登入');
                    return;
                }

                const messagesContainer = document.getElementById('messagesContainer');
                if (!messagesContainer) {
                    console.error('找不到消息容器');
                    return;
                }
                
                messagesContainer.innerHTML = '';

                const chatRef = firebase.database().ref(`chats/${user.uid}/${character}`);
                
                // 移除之前的監聽器
                chatRef.off('child_added');
                
                // 只獲取歷史消息，不使用實時監聽
                const snapshot = await chatRef.orderByChild('timestamp').once('value');
                
                // 按時間順序顯示消息
                const messages = [];
                snapshot.forEach((childSnapshot) => {
                    messages.push(childSnapshot.val());
                });

                messages.sort((a, b) => a.timestamp - b.timestamp);
                
                messages.forEach((chat) => {
                    if (chat && chat.message) {
                        addMessage(chat.message, chat.type, chat.actionInfo);
                    }
                });

            } catch (error) {
                console.error('載入聊天記錄錯誤：', error);
                showToast('載入聊天記錄失敗', 'error');
            }
        }

        // 修改表單初始化函數
        function initializeMessageForm() {
            const messageForm = document.getElementById('messageForm');
            if (!messageForm) return;

            // 移除所有現有的事件監聽器
            const newMessageForm = messageForm.cloneNode(true);
            messageForm.parentNode.replaceChild(newMessageForm, messageForm);

            // 重新獲取輸入框引用
            const messageInput = newMessageForm.querySelector('#messageInput');
            if (messageInput) {
                messageInput.value = ''; // 清空輸入框
            }

            // 添加新的事件監聽器
            newMessageForm.addEventListener('submit', handleSubmit, { once: true }); // 使用 once: true 確保事件只觸發一次
        }

        // 修改載入角色頭像的函數
        function loadCharacterAvatar(character) {
            const avatarImg = document.getElementById('characterAvatar');
            if (avatarImg && character) {
                // 根據角色選擇不同的頭像
                switch(character) {
                    case '楪析':
                        avatarImg.src = '楪析.jpeg';
                        break;
                    case '霸總':
                        avatarImg.src = '霸總.jpeg';
                        break;
                    case '望宇':
                        avatarImg.src = '望宇.jpeg';
                        break;
                    default:
                        avatarImg.src = 'default.jpeg';
                }
                avatarImg.alt = `${character}的頭像`;
                
                // 添加錯誤處理
                avatarImg.onerror = function() {
                    console.error(`無法載入${character}的頭像`);
                    this.src = 'default.jpg';
                };
            }
        }

        // 添加初始化關係值的函數
        async function initializeRelationshipValue() {
            try {
                const character = localStorage.getItem('selectedCharacter');
                const user = firebase.auth().currentUser;
                
                if (user && character) {
                    // 從 Firebase 讀取關係值
                    const snapshot = await firebase.database()
                        .ref(`relationships/${user.uid}/${character}`)
                        .once('value');

                    if (snapshot.exists()) {
                        relationshipValue = snapshot.val().value || 0;
                    } else {
                        relationshipValue = 0;
                    }

                    // 更新 localStorage
                    localStorage.setItem('relationshipValue', relationshipValue);
                    
                    // 更新 UI
                    updateRelationshipUI();
                }
                } catch (error) {
                console.error('初始化關係值錯誤：', error);
                relationshipValue = 0;
                updateRelationshipUI();
            }
        }

        // 修改 DOMContentLoaded 事件處理
        document.addEventListener('DOMContentLoaded', function() {
            firebase.auth().onAuthStateChanged(async (user) => {
                try {
                if (user) {
                    const character = localStorage.getItem('selectedCharacter');
                    if (character) {
                            const chatTitle = document.getElementById('chatTitle');
                            const userEmail = document.getElementById('userEmail');
                            
                            if (chatTitle) {
                                chatTitle.textContent = `與 ${character} 聊天中`;
                            }
                            if (userEmail) {
                                userEmail.textContent = user.email.split('@')[0];
                            }
                            
                            // 先初始化關係值，再載入聊天記錄
                            await initializeRelationshipValue();
                        await loadChatHistory(character);
                            
                            // 初始化表單
                            initializeMessageForm();

                            // 載入角色頭像
                            loadCharacterAvatar(character);
                        } else {
                            console.error('未選擇角色');
                            window.location.href = 'index.html';
                        }
                } else {
                    window.location.href = 'login.html';
                    }
                } catch (error) {
                    console.error('初始化錯誤：', error);
                    showToast('載入失敗，請重新整理頁面', 'error');
                }
            });

            // 確保消息容器存在
            const messagesContainer = document.getElementById('messagesContainer');
            if (messagesContainer) {
                // 添加初始系統消息
                addSystemMessage('開始新的對話吧！');
            }
        });

        // 登出功能
        function signOut() {
            firebase.auth().signOut().then(() => {
                window.location.href = 'login.html';
            }).catch((error) => {
                console.error('登出錯誤：', error);
                alert('登出時發生錯誤，請稍後再試');
            });
        }

        // 添加確認對話框函數
        function showConfirmDialog(title, message) {
            return new Promise((resolve) => {
                const dialog = document.createElement('div');
                dialog.className = 'fixed inset-0 z-50 flex items-center justify-center p-4 bg-black bg-opacity-50';
                dialog.innerHTML = `
                    <div class="bg-white rounded-lg p-6 max-w-sm w-full shadow-xl transform transition-all">
                        <h3 class="text-lg font-medium text-gray-900 mb-2">${title}</h3>
                        <p class="text-sm text-gray-500 mb-4">${message}</p>
                        <div class="flex justify-end gap-3">
                            <button class="cancel-btn px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-100 rounded-md transition-colors">
                                取消
                            </button>
                            <button class="confirm-btn px-4 py-2 text-sm font-medium text-white bg-red-600 hover:bg-red-700 rounded-md transition-colors">
                                確定重置
                            </button>
                        </div>
                    </div>
                `;

                document.body.appendChild(dialog);

                dialog.querySelector('.cancel-btn').onclick = () => {
                    dialog.remove();
                    resolve(false);
                };

                dialog.querySelector('.confirm-btn').onclick = () => {
                    dialog.remove();
                    resolve(true);
                };
            });
        }

        // 添加提示消息函數
        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `fixed top-4 left-1/2 transform -translate-x-1/2 z-50 px-4 py-2 rounded-lg shadow-lg ${
                type === 'success' ? 'bg-green-500' : 'bg-red-500'
            } text-white text-sm font-medium`;
            toast.textContent = message;
            
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translate(-50%, -20px)';
                setTimeout(() => toast.remove(), 300);
            }, 2000);
        }

        // 修改計算關係值變化的函數
        function calculateRelationshipChange(message, response) {
            let change = 0;
            
            // 深度互動指標
            const depthIndicators = {
                '分享秘密': 3,      // 當用戶透露個人資訊
                '回憶童年': 2,      // 提及成長經歷
                '未來想像': 2,      // 討論未來計劃
                '肢體描述': 1.5,    // 提到具體身體反應
                '專屬暱稱': 2       // 使用獨特稱呼
            };

            // 情感詞彙檢測
            const emotionalWords = {
                '楪析': ['速寫本', '畫室', '雨聲', '鳶尾花'],
                '霸總': ['晨跑', '咖啡豆', '領帶', '星空'],
                '望宇': ['籃球', '浪浪', '耳釘', '抹茶']
            };

            // 檢查角色專屬詞彙
            const character = localStorage.getItem('selectedCharacter');
            if (emotionalWords[character].some(w => message.includes(w))) {
                change += 2;
            }

            // 基礎分數
            change += 1;

            // 根據訊息長度加分
            if (message.length > 20) change += 1;

            // 根據關鍵字加分
            const positiveKeywords = ['喜歡', '愛', '想你', '謝謝', '關心', '想見', '抱抱', '親親', '寶貝', '親愛', '甜蜜'];
            positiveKeywords.forEach(keyword => {
                if (message.includes(keyword)) change += 2;
            });

            // 根據互動頻率加分
            const lastInteractionTime = localStorage.getItem('lastInteractionTime');
            const now = Date.now();
            if (lastInteractionTime) {
                const timeDiff = now - parseInt(lastInteractionTime);
                if (timeDiff < 1000 * 60 * 5) { // 5分鐘內
                    change += 1;
                }
            }
            localStorage.setItem('lastInteractionTime', now.toString());

            // 限制最大值和每次增加的最大值
            change = Math.min(5, change); // 每次最多增加5點
            relationshipValue = Math.min(100, relationshipValue + change);
            
            // 更新 UI 和保存
            updateRelationshipUI();
            saveRelationshipValue();
        }

        // 修改保存關係值的函數
        function saveRelationshipValue() {
            const character = localStorage.getItem('selectedCharacter');
            const user = firebase.auth().currentUser;
            if (user && character) {
                firebase.database().ref(`relationships/${user.uid}/${character}`).set({
                    value: relationshipValue,
                    updatedAt: firebase.database.ServerValue.TIMESTAMP
                });
            }
        }

        // 新增辅助函数
        function hasContradiction(history, response) {
            const last3 = history.slice(-3).map(c => c.message);
            const keywords = extractKeywords(response);
            return last3.some(msg => 
                keywords.some(kw => 
                    msg.includes(kw) && response.indexOf(kw) === -1
                )
            );
        }

        async function retryGenerate(prompt, error) {
            const retryPrompt = `${prompt}\n\n修正要求：${error}`;
            // 重新生成逻辑...
        }
    </script>
</body>
</html> 